// Generated by CoffeeScript 2.0.2
(function() {
  var dicts, dumpobj, lts, main, sets, statespace;

  sets = require("./sets");

  dicts = require("./dicts");

  statespace = function(init, addsucc, print_states, print_succs, print_dead) {
    var dead, i, ref, s, seen, state, succ, todo;
    i = init();
    i.id = 0;
    todo = new sets.Queue(i);
    seen = new sets.Set(i);
    dead = 0;
    while (!todo.empty()) {
      state = todo.get();
      succ = new sets.Set();
      addsucc(state, succ);
      if (succ.empty()) {
        dead += 1;
      }
      if ((print_dead && succ.empty()) || print_states) {
        console.log(state.toString());
      }
      ref = succ.iter();
      for (s of ref) {
        if (seen.has(s)) {
          s = seen.get(s);
        } else {
          s.id = seen.len();
          seen.add(s);
          todo.put(s);
        }
        if (print_succs) {
          console.log(">", s.toString());
        }
      }
    }
    return [seen.len(), dead];
  };

  dumpobj = function(obj) {
    var k, v;
    return "{" + ((function() {
      var results;
      results = [];
      for (k in obj) {
        v = obj[k];
        results.push(`'${k}': ${v}`);
      }
      return results;
    })()).join(", ") + "}";
  };

  lts = function(init, itersucc) {
    var add, i, mode, results, seen, state, sub, succ, todo, trans;
    i = init();
    i.id = 0;
    todo = new sets.Queue(i);
    seen = new sets.Set(i);
    results = [];
    while (!todo.empty()) {
      state = todo.get();
      console.log(state.toString());
      results.push((function() {
        var ref, results1, x;
        ref = itersucc(state);
        results1 = [];
        for (x of ref) {
          [trans, mode, sub, add] = x;
          succ = state.copy().sub(sub).add(add);
          if (seen.has(succ)) {
            succ = seen.get(succ);
          } else {
            succ.id = seen.len();
            seen.add(succ);
            todo.put(succ);
          }
          console.log(`@ ${trans} = ${dumpobj(mode)}`);
          console.log(` - ${sub.toString()}`);
          console.log(` + ${add.toString()}`);
          results1.push(console.log(` > ${succ.toString()}`));
        }
        return results1;
      })());
    }
    return results;
  };

  main = function(name, init, addsucc, itersucc) {
    var args, c, d, j, len, ref, s;
    args = {
      s: false,
      d: false,
      m: false,
      g: false,
      l: false
    };
    ref = process.argv.slice(2).join("");
    for (j = 0, len = ref.length; j < len; j++) {
      c = ref[j];
      if (args[c] != null) {
        args[c] = true;
      } else if (c === "-") {

      // skip
      } else if (c === "h") {
        console.log(`usage: ${name} [-s] (-d|-g|-m|-l|-h)`);
        console.log("  options:");
        console.log("    -l   labelled transitions system");
        console.log("    -g   print marking graph");
        console.log("    -m   only print markings");
        console.log("    -d   only print deadlocks");
        console.log("    -s   only print size");
        console.log("    -h   print help and exit");
        return;
      } else {
        console.log(`invalid option ${c}, try -h for help`);
        return;
      }
    }
    if (args.s) {
      [s, d] = statespace(init, addsucc, false, false, false);
      if (args.d) {
        return console.log(`${d} deadlocks`);
      } else {
        return console.log(`${s} reachable states`);
      }
    } else if (args.l) {
      return lts(init, itersucc);
    } else if (args.g) {
      return statespace(init, addsucc, true, true, false);
    } else if (args.m) {
      return statespace(init, addsucc, true, false, false);
    } else if (args.d) {
      return statespace(init, addsucc, false, false, true);
    } else {
      return console.log("missing option, try -h for help");
    }
  };

  module.exports = {
    statespace: statespace,
    lts: lts,
    main: main
  };

}).call(this);

//# sourceMappingURL=main.js.map
